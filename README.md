# AI Chess Mate Solver: Detecting Checkmate in a Few Moves

Welcome to the **AI Chess Mate Solver**!
This project is an AI agent designed to detect checkmate sequences in just a few moves from various chess positions. It uses a combination of classic search algorithms—**Depth-First Search (DFS)**, **Breadth-First Search (BFS)**, **Minimax**, and **Alpha-Beta Pruning**—to explore the game tree efficiently and find winning moves.

---

## Table of Contents

1. [Introduction](#-introduction)
2. [Key Features](#-key-features)
3. [How It Works](#-how-it-works)
4. [Algorithms in Action](#-algorithms-in-action)
5. [Prerequisits](#-installation--setup)
6. [Future Enhancements](#-future-enhancements)

---

## Introduction

The project is built with Python and features interactive visualization using `pygame`. With multiple algorithm choices, you can analyze their performance and discover how AI evaluates different move sequences.

---

## Key Features

**Multiple Search Algorithms** – DFS, BFS, Minimax, and Alpha-Beta Pruning.

**Customizable Positions** – Load chess positions using FEN (Forsyth-Edwards Notation) for personalized gameplay analysis.

**Performance Tracking** – Measure execution time and efficiency of different algorithms.

**Accurate Checkmate Detection** – The AI finds the shortest path to checkmate.

---

## How It Works

1. **Load a Chess Position** – Input a position using FEN notation or select from preloaded scenarios in the positions folder, and write the name of the file in main.py.
2. **Select an Algorithm** – Choose DFS, BFS, Minimax, or Alpha-Beta Pruning to analyze the position.
3. **Run the Solver** – The AI searches for a sequence of moves leading to checkmate.
4. **Review Performance** – Compare how long each algorithm takes to solve the problem.

---

## Algorithms in Action

### Depth-First Search (DFS)

Depth-First Search (DFS) is a search procedure that explores the deepest available moves in the game tree prior to backtracking. DFS is useful when applied to chess because it allows the agent to extensively simulate sequences of moves prior to examining alternatives.
Whenever DFS is analyzing a chess position, it performs the following:
The first algorithm I implemented was DFS. On average, this algorithm is the fastest among all in the code.

The dfs function takes the current board state, the current depth, the maximum allowed depth, the player on turn, and lists to track the move sequence and executed moves.
At the beginning, the current board state is saved using board.generate_fen() and board.get_state() so that it can be restored later if needed. If the function detects that the game is over, it displays the move sequence and returns the board with the executed moves.
If the game is not over, all possible moves for the current player are generated. To do this, it first retrieves all legal moves from board_1.legal_moves, which is essentially an array of legal moves generated by the original Python chess library. Then, I compare these with the moves found by my algorithm to eliminate illegal ones. So far, my algorithm has not been found to generate illegal moves as legal, but this method further reinforces its accuracy.
Once a valid list of moves is obtained, the algorithm tests them one by one. Each move is added to the sequence, and the piece is moved to its new position. Then, the current player is switched, and dfs is called recursively for the next move.
If no solution is found, the board is reverted to its previous state, the last move is removed from the sequence, and the algorithm proceeds with the next possible move. If the maximum depth is reached, the algorithm does not go deeper.
DFS is memory-efficient since it only needs to keep track of the present path being explored and not remember all visited locations. Though it doesn't calculate the most optimal moves for the players, the algorithm is one of the quickest to find checkmates.
If a result is found, it is returned as the function’s output. If no successful sequence is found, the function returns None.
I have not noticed any issues with this algorithm.


### Breadth-First Search (BFS)

The bfs function recursively finds possible chess moves using a BFS-based queue traversal. The function uses queue operations with maximum efficiency in BFS traversal. The function supports dynamic move generation through a conversion system to convert between move formats. The state of the game is checked after each move to detect game-over conditions prematurely and avoid duplicate computations.

### Minimax Algorithm

Implementing this algorithm was the most challenging part since I later used an almost identical function for Alpha-Beta pruning, with just two additional variables.
Minimax is executed in two functions: minmaxing and minimax. The maximum depth is calculated as the number of moves to checkmate multiplied by 2, minus 1. This is because if, for example, we start with black pieces and attempt to checkmate the white player in n moves, the opponent will play n-1 moves.
In this function, I implemented legality checks using the chess library. This was the first place where I began comparing the legal moves I generated against those generated by the library using the same FEN string. To achieve this, I use show_differences from the board class.
From all generated legal moves, I start with the first one, set the isMaximising variable to False so that the next move goes to the opponent, and call the minimax function. Within minimax, the logic branches depending on isMaximising. The key concept is that for the initial player, the best result is the highest heuristic value, whereas for the opponent, the best result is the lowest heuristic value.

The main problem with this algorithm is its time and space complexity. I revert to previous board states by saving and restoring them, but this turned out to be a very costly and slow operation. I attempted to optimize this by implementing an undo function that only handles the last performed move, but I encountered numerous errors when one player captured an opponent's piece.
Besides undo, I also attempted to store board states and pass them around, but until recently, generating a FEN string was the only reliable solution that did not cause any issues. The code now uses an undo function, that returns a captured piece (if there is one in the first place) directly to the minimax function. This solution sped up the algorithm 4 times.
Additionally, when multiple pieces are available, the algorithm generates all possible legal moves, creates FEN strings, and compares heuristic values, leading to significantly longer execution times compared to BFS or DFS. The minimax algorithm does not find just one checkmate—it identifies all possible checkmate sequences under the assumption that both players make optimal moves. It returns the best result along with the sequence of moves that generate this optimal result.

### Alpha-Beta Pruning

After implementing Minimax, I immediately noticed that execution time was very long. The primary reason for this was that the algorithm explored every possible move in the decision tree, even when some moves were obviously unnecessary. To optimize this, I added Alpha-Beta pruning—a more efficient version of Minimax that reduces the number of explored nodes. The implementation of this function was nearly identical to the minimax function, except that it included two additional parameters: alpha and beta.

Alpha stores the best value the MAX player can guarantee in any branch, beta stores the worst value the MIN player can guarantee in any branch. Instead of analyzing all possible moves, the algorithm prunes entire subtrees from the search when it is clear they will not affect the final outcome. This significantly reduces time complexity without affecting the accuracy of the results. From my experiments, the optimal initial values for alpha and beta were 100 and any number greater than 500, respectively (since my evaluation function cannot produce such a high heuristic value).
Optimization was achieved by fixing the undo function. Initially, I stored captured_piece inside the class, but now, every captured piece is passed as an argument to the function. This ensures that captured pieces are not "lost" when the search deepens.
The speedup was at least 30 times for Alpha-Beta pruning! The same board instance persists without needing to be recreated multiple times, and I no longer generate new piece objects. Instead, I consistently work with the same set of up to 32 pieces, which I previously struggled to achieve.

---

## Prerequisites

Make sure you have Python installed along with the necessary libraries:

```bash
pip install pygame chess
```

---

## Future Enhancements

Implementing a GUI for easier input and interaction.

Implement other searching algorithms to compare performances.
